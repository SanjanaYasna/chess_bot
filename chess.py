# -*- coding: utf-8 -*-
"""Chess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PIAorBNQs7H5usjQRajv-NTD6O91V0vk
"""

pip install chess

import chess

board = chess.Board()

print(board.legal_moves)

import sys
import random
from datetime import datetime

import chess


def print_board(board: chess.Board) -> None:
    print("\nCurrent Board Position:")
    print("----------------------")
    print(board)
    print("----------------------\n")


def side_name(color: chess.Color) -> str:
    return "white" if color == chess.WHITE else "black"


def parse_color(s: str) -> chess.Color | None:
    s = s.strip().lower()
    if s in {"w", "white"}:
        return chess.WHITE
    if s in {"b", "black"}:
        return chess.BLACK
    return None


def choose_bot_move(board: chess.Board) -> chess.Move: #choosing capture before legal moves
    legal = list(board.legal_moves)
    if not legal:
        raise RuntimeError("No legal moves available.")
    captures = [m for m in legal if board.is_capture(m)]
    pool = captures if captures else legal
    return random.choice(pool)


def print_fen(board: chess.Board) -> None:
    print(f"New FEN position: {board.fen()}")


def prompt_user_move(board: chess.Board) -> chess.Move:
    side = "White" if board.turn == chess.WHITE else "Black"
    while True:
        s = input(f"{side}: ").strip().lower()
        if s in {"quit", "exit"}:
            print("Goodbye.")
            sys.exit(0)
        if s in {"resign"}:
            loser = side.lower()
            winner = "black" if loser == "white" else "white"
            print(f"{loser.capitalize()} resigns. {winner.capitalize()} wins.")
            sys.exit(0)
        try:
            mv = chess.Move.from_uci(s)
        except ValueError:
            print("Invalid format. Use UCI like e2e4 or a7a8q.")
            continue
        if mv in board.legal_moves:
            return mv
        print("Illegal move in this position. Try again.")


def announce_game_over(board: chess.Board) -> None:
    if board.is_checkmate():
        winner = "white" if board.turn == chess.BLACK else "black"
        print(f"Checkmate. {winner.capitalize()} wins.")
        return
    if board.is_stalemate():
        print("Draw by stalemate.")
        return
    if board.is_insufficient_material():
        print("Draw by insufficient material.")
        return
    if board.is_seventyfive_moves():
        print("Draw by 75-move rule.")
        return
    if board.is_fivefold_repetition():
        print("Draw by fivefold repetition.")
        return
    print("Game over.")


def run_game(board: chess.Board, bot_color: chess.Color) -> None:
    while True:
        if board.is_game_over():
            announce_game_over(board)
            return

        if board.turn == bot_color:
            mv = choose_bot_move(board)
            print(f"Bot (as {side_name(bot_color)}): {mv.uci()}")
            board.push(mv)
            print_fen(board)
            continue

        user_mv = prompt_user_move(board)
        board.push(user_mv)
        print_fen(board)


def main() -> None:
    print(f"Time: {datetime.now()}")
    print("Computer Player? (w=white/b=black):")
    user_color_in = input().strip().lower()
    bot_color = parse_color(user_color_in)
    if bot_color is None:
        print("Invalid input. Please enter 'w' for white or 'b' for black.")
        sys.exit(1)

    board = chess.Board()  # default start
    print("Starting FEN position? (hit ENTER for standard starting postion):")
    pos = input().strip()
    if pos:
        try:
            board.set_fen(pos)
        except ValueError:
            print("Invalid FEN string. Using standard starting position.")
            board.set_fen(chess.STARTING_FEN)
    else:
        board.set_fen(chess.STARTING_FEN)

    run_game(board, bot_color)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted. Bye.")