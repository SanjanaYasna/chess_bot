# -*- coding: utf-8 -*-
"""Chess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PIAorBNQs7H5usjQRajv-NTD6O91V0vk
"""

import chess
board = chess.Board()

# print(board.legal_moves)

import sys
import random
from datetime import datetime


def print_board(board: chess.Board) -> None:
    print("\nCurrent Board Position:")
    print("----------------------")
    print(board)
    print("----------------------\n")


def side_name(color: chess.Color) -> str:
    return "white" if color == chess.WHITE else "black"


def parse_color(s: str) -> chess.Color | None:
    s = s.strip().lower()
    if s in {"w", "white"}:
        return chess.WHITE
    if s in {"b", "black"}:
        return chess.BLACK
    return None


def choose_bot_move(board: chess.Board) -> chess.Move: #choosing capture before legal moves
    legal = list(board.legal_moves)
    if not legal:
        raise RuntimeError("No legal moves available.")
    captures = [m for m in legal if board.is_capture(m)]
    pool = captures if captures else legal
    return random.choice(pool)


def print_fen(board: chess.Board) -> None:
    print(f"New FEN position: {board.fen()}")


def prompt_user_move(board: chess.Board) -> chess.Move:
    side = "White" if board.turn == chess.WHITE else "Black"
    while True:
        s = input(f"{side}: ").strip().lower()
        if s in {"quit", "exit"}:
            print("Goodbye.")
            sys.exit(0)
        if s in {"resign"}:
            loser = side.lower()
            winner = "black" if loser == "white" else "white"
            print(f"{loser.capitalize()} resigns. {winner.capitalize()} wins.")
            sys.exit(0)
        try:
            mv = chess.Move.from_uci(s)
        except ValueError:
            print("Invalid format. Use UCI like e2e4 or a7a8q.")
            continue
        if mv in board.legal_moves:
            return mv
        print("Illegal move in this position. Try again.")

#returns num in case we want to assert a certain outcome
def announce_game_over(board: chess.Board) -> None:
    if board.is_checkmate():
        winner = "white" if board.turn == chess.BLACK else "black"
        print(f"Checkmate. {winner.capitalize()} wins.")
        return 1
    if board.is_stalemate():
        print("Draw by stalemate.")
        return 2
    if board.is_insufficient_material():
        print("Draw by insufficient material.")
        return 3
    if board.is_seventyfive_moves():
        print("Draw by 75-move rule.")
        return 4
    if board.is_fivefold_repetition():
        print("Draw by fivefold repetition.")
        return 5
    print("Game over.")
    
def run_game_two_bots_greedy_vs_random(board: chess.Board, greedy_color: chess.Color) -> None:
    while True:
        if board.is_game_over():
            num_outcome = announce_game_over(board)
            return num_outcome
        #white bot
        if board.turn == chess.WHITE:
            if greedy_color != chess.WHITE:
                legal = list(board.legal_moves)
                if not legal:
                    raise RuntimeError("No legal moves available.")
                mv = random.choice(legal)
                print(f"Bot 1, any legal move (as white): {mv.uci()}")
                board.push(mv)
            else:
                #if it is greedy, it choosees the capture moves specificially
                mv = choose_bot_move(board)
                print(f"Bot 1, prioritizes capture (as white): {mv.uci()}")
                board.push(mv)
        else:
            if greedy_color != chess.BLACK:
                legal = list(board.legal_moves)
                if not legal:
                    raise RuntimeError("No legal moves available.")
                mv = random.choice(legal)
                print(f"Bot 2, any legal move (as black): {mv.uci()}")
                board.push(mv)
            else:
                mv = choose_bot_move(board)
                print(f"Bot 2, prioritizes capture (as black): {mv.uci()}")
                board.push(mv)
        prints(board)
        continue

def prints(board):
    print_fen(board)
    print_board(board)
#both bots do capture move, print not only fen but also current board state for visibility
def run_game_two_bots_greedy(board: chess.Board) -> None:
    while True:
        if board.is_game_over():
            num_outcome = announce_game_over(board)
            return num_outcome
        #white bot
        if board.turn == chess.WHITE:
            mv = choose_bot_move(board)
            print(f"Bot 1 (as white): {mv.uci()}")
            board.push(mv)
        else:
            mv = choose_bot_move(board)
            print(f"Bot 2 (as black): {mv.uci()}")
            board.push(mv)
        prints(board)
        continue

def run_game(board: chess.Board, bot_color: chess.Color) -> None:
    while True:
        if board.is_game_over():
            announce_game_over(board)
            return

        if board.turn == bot_color:
            mv = choose_bot_move(board)
            print(f"Bot (as {side_name(bot_color)}): {mv.uci()}")
            board.push(mv)
            print_fen(board)
            #print_board(board)
            continue

        user_mv = prompt_user_move(board)
        board.push(user_mv)
        print_fen(board)
      #  print_board(board)


def print_board(board):
    print("\nCurrent Board Position:")
    print("----------------------")
    print(board)
    print("----------------------\n")
    
def main() -> None:
    print("Just in case we need teh header:")
    print("=====================================================")
    print("             CS 290 Chess Bot Version 0.1            ")
    print("=====================================================")
    print(f"Time: {datetime.now()}")
    print("Computer Player? (w=white/b=black):")
    user_color_in = input().strip().lower()
    bot_color = parse_color(user_color_in)
    if bot_color is None:
        print("Invalid input. Please enter 'w' for white or 'b' for black.")
        sys.exit(1)

    board = chess.Board()  # default start
    print("Starting FEN position? (hit ENTER for standard starting postion):")
    pos = input().strip()
    if pos:
        try:
            board.set_fen(pos)
        except ValueError:
            print("Invalid FEN string. Using standard starting position.")
            board.set_fen(chess.STARTING_FEN)
    else:
        board.set_fen(chess.STARTING_FEN)
    #print_board(board)
    run_game(board, bot_color)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted. Play again soon.")