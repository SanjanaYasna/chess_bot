# -*- coding: utf-8 -*-
"""Chess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PIAorBNQs7H5usjQRajv-NTD6O91V0vk
"""

import chess
board = chess.Board()

# print(board.legal_moves)

import sys
import random
from datetime import datetime


def print_board(board: chess.Board) -> None:
    print("\nCurrent Board Position:")
    print("----------------------")
    print(board)
    print("----------------------\n")


def side_name(color: chess.Color) -> str:
    return "white" if color == chess.WHITE else "black"


def parse_color(s: str) -> chess.Color | None:
    s = s.strip().lower()
    if s in {"w", "white"}:
        return chess.WHITE
    if s in {"b", "black"}:
        return chess.BLACK
    return None


def choose_bot_move(board: chess.Board) -> chess.Move: #choosing capture before legal moves
    legal = list(board.legal_moves)
    if not legal:
        raise RuntimeError("No legal moves available.")
    captures = [m for m in legal if board.is_capture(m)]
    pool = captures if captures else legal
    return random.choice(pool)


def print_fen(board: chess.Board) -> None:
    print(f"New FEN position: {board.fen()}")


def prompt_user_move(board: chess.Board) -> chess.Move:
    side = "White" if board.turn == chess.WHITE else "Black"
    while True:
        s = input(f"{side}: ").strip().lower()
        if s in {"quit", "exit"}:
            print("Goodbye.")
            sys.exit(0)
        if s in {"resign"}:
            loser = side.lower()
            winner = "black" if loser == "white" else "white"
            print(f"{loser.capitalize()} resigns. {winner.capitalize()} wins.")
            sys.exit(0)
        try:
            mv = chess.Move.from_uci(s)
        except ValueError:
            print("Invalid format. Use UCI like e2e4 or a7a8q.")
            continue
        if mv in board.legal_moves:
            return mv
        print("Illegal move in this position. Try again.")

#returns num in case we want to assert a certain outcome
def announce_game_over(board: chess.Board) -> None:
    if board.is_checkmate():
        winner = "white" if board.turn == chess.BLACK else "black"
        print(f"Checkmate. {winner.capitalize()} wins.")
        return 1
    if board.is_stalemate():
        print("Draw by stalemate.")
        return 2
    if board.is_insufficient_material():
        print("Draw by insufficient material.")
        return 3
    if board.is_seventyfive_moves():
        print("Draw by 75-move rule.")
        return 4
    if board.is_fivefold_repetition():
        print("Draw by fivefold repetition.")
        return 5
    print("Game over.")
    
def run_game_two_bots_greedy_vs_random(board: chess.Board, greedy_color: chess.Color) -> None:
    while True:
        if board.is_game_over():
            num_outcome = announce_game_over(board)
            return num_outcome
        #white bot
        if board.turn == chess.WHITE:
            if greedy_color != chess.WHITE:
                legal = list(board.legal_moves)
                if not legal:
                    raise RuntimeError("No legal moves available.")
                mv = random.choice(legal)
                print(f"Bot 1, any legal move (as white): {mv.uci()}")
                board.push(mv)
            else:
                #if it is greedy, it choosees the capture moves specificially
                mv = choose_bot_move(board)
                print(f"Bot 1, prioritizes capture (as white): {mv.uci()}")
                board.push(mv)
        else:
            if greedy_color != chess.BLACK:
                legal = list(board.legal_moves)
                if not legal:
                    raise RuntimeError("No legal moves available.")
                mv = random.choice(legal)
                print(f"Bot 2, any legal move (as black): {mv.uci()}")
                board.push(mv)
            else:
                mv = choose_bot_move(board)
                print(f"Bot 2, prioritizes capture (as black): {mv.uci()}")
                board.push(mv)
        prints(board)
        continue

def prints(board):
    print_fen(board)
    print_board(board)
    

#both bots do capture move, print not only fen but also current board state for visibility
def run_game_two_bots_greedy(board: chess.Board) -> None:
    while True:
        if board.is_game_over():
            num_outcome = announce_game_over(board)
            return num_outcome
        #white bot
        if board.turn == chess.WHITE:
            mv = choose_bot_move(board)
            print(f"Bot 1 (as white): {mv.uci()}")
            board.push(mv)
        else:
            mv = choose_bot_move(board)
            print(f"Bot 2 (as black): {mv.uci()}")
            board.push(mv)
        prints(board)
        continue

#min max depth 2
"""
Valuatino: + - 10 for capturing queen
Pawn : + - 1
Rook : 
Knight: 
Bishop:
"""
def choose_best_move_depth_2(board: chess.Board, bot_color: chess.Color) -> chess.Move:
    best_score = -float('inf')
    best_move = None
    print("CALLED")
    #iterate moves available to bot
    for mv in board.legal_moves:
        move = chess.Move.from_uci(mv.uci())
        #bot score is positive score from bot doing move
        bot_score = 0
        if board.is_capture(move):
            #queen is + 10
            if board.piece_at(move.to_square).piece_type == 5: #queen
                bot_score += 10
            elif board.piece_at(move.to_square).piece_type == 1: #pawn
                bot_score += 1
            elif board.piece_at(move.to_square).piece_type == 4: #rook
                bot_score += 5
            elif board.piece_at(move.to_square).piece_type == 3: #bishop
                bot_score += 3
            else: #knight, 6
                bot_score += 3
            #score remains 0 if no capture
        print(f"Evaluating move: {move.uci()} with bot score: {bot_score}")
        #push move, then see opponent moves to score
        board.push(move)
        for opponent_mv in board.legal_moves:
            opponent_move = chess.Move.from_uci(opponent_mv.uci())
            opponent_score = 0
            if board.is_capture(opponent_move):
                #SUBTRACT score by opponent captures
                if board.piece_at(opponent_move.to_square).piece_type == 5: #queen
                    bot_score -= 10 
                elif board.piece_at(opponent_move.to_square).piece_type == 1: #pawn
                    bot_score -= 1
                elif board.piece_at(opponent_move.to_square).piece_type == 4: #rook
                    bot_score -= 5
                elif board.piece_at(opponent_move.to_square).piece_type == 3: #bishop
                    bot_score -= 3
                else: #knight, 6
                    bot_score -= 3
            print(f"    Opponent evaluating move: {opponent_move.uci()} with opponent score: {opponent_score}") 
            #update best score if needed
            if bot_score > best_score:
                best_score = bot_score
                best_move = move
        board.pop()  # Undo opponent move
        board.pop()  # Undo bot move    
        return best_move, best_score
             
"""
IGNORE: Min-Max algorithm depth of just 2
"""
#TODO in progress
# def run_game_min_max(board: chess.Board, bot_color: chess.Color) -> None:
#     while True:
#         if board.is_game_over():
#             announce_game_over(board)
#             return

#         if board.turn == bot_color:
#             mv =1 #TODO implement move chosen
            
#             print(f"Bot (as {side_name(bot_color)}): {mv.uci()}")
#             board.push(mv)
#             print_fen(board)
#             continue

def run_game(board: chess.Board, bot_color: chess.Color) -> None:
    while True:
        if board.is_game_over():
            announce_game_over(board)
            return

        if board.turn == bot_color:
            mv = choose_bot_move(board)
            choose_best_move_depth_2(board, bot_color)  
            print(f"Bot (as {side_name(bot_color)}): {mv.uci()}")
            board.push(mv)
            print_fen(board)
            #print_board(board)
            continue

        user_mv = prompt_user_move(board)
        board.push(user_mv)
        print_fen(board)
        print_board(board)


def print_board(board):
    print("\nCurrent Board Position:")
    print("----------------------")
    print(board)
    print("----------------------\n")
    
def main() -> None:
    print("Just in case we need teh header:")
    print("=====================================================")
    print("             CS 290 Chess Bot Version 0.1            ")
    print("=====================================================")
    print(f"Time: {datetime.now()}")
    print("Computer Player? (w=white/b=black):")
    user_color_in = input().strip().lower()
    bot_color = parse_color(user_color_in)
    if bot_color is None:
        print("Invalid input. Please enter 'w' for white or 'b' for black.")
        sys.exit(1)

    board = chess.Board()  # default start
    print("Starting FEN position? (hit ENTER for standard starting postion):")
    pos = input().strip()
    if pos:
        try:
            board.set_fen(pos)
        except ValueError:
            print("Invalid FEN string. Using standard starting position.")
            board.set_fen(chess.STARTING_FEN)
    else:
        board.set_fen(chess.STARTING_FEN)
    #print_board(board)
    run_game(board, bot_color)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted. Play again soon.")